import json
import argparse
import logging
import os
import shutil
from collections import namedtuple
from downloader import artifactory_dict

import requests

import set_log


def main():
    set_log.set_logger()

    settings_path = parse_args()
    if not settings_path:
        return

    with open(settings_path, "r") as file:
        settings = json.load(file, object_hook=lambda d: namedtuple('X', d.keys())(*d.values()))

    url = get_build_link(settings)
    if url:
        download_file(settings, url)


def get_build_link(settings):
    if not settings.username or not settings.password:
        logging.error("Please provide username and artifactory password")
        return False

    server = artifactory_dict[settings.artifactory]
    try:
        with requests.get(server + "/api/repositories", auth=(settings.username, settings.password),
                          timeout=30) as url_request:
            artifacts_list = json.loads(url_request.text)
    except requests.exceptions.ReadTimeout:
        logging.error("Timeout on connection, please verify your username and password for {}".format(
            settings.artifactory))
        return False

    # catch 401 for bad credentials or similar
    if "errors" in artifacts_list:
        if artifacts_list["errors"][0]["status"] == 401:
            logging.error("Bad credentials, please verify your username and password for {}".format(
                settings.artifactory))
        else:
            logging.error(artifacts_list["errors"][0]["message"])
        return

    # fill the dictionary with EBU and WB keys since builds could be different
    # still parse the list because of different names on servers
    artifacts_dict = {}
    for artifact in artifacts_list:
        repo = artifact["key"]
        if "EBU_Certified" in repo:
            version = repo.split("_")[0] + "_EBU"
            if version not in artifacts_dict:
                artifacts_dict[version] = repo
        elif "Certified" in repo and "Licensing" not in repo:
            version = repo.split("_")[0] + "_WB"
            if version not in artifacts_dict:
                artifacts_dict[version] = repo

    repo = artifacts_dict[settings.version]
    if "EDT" in settings.version:
        url = server + "/api/storage/" + repo + "?list&deep=0&listFolders=1"
        with requests.get(url, auth=(settings.username, settings.password), timeout=30) as url_request:
            folder_dict_list = json.loads(url_request.text)['files']

        builds_dates = []
        for folder_dict in folder_dict_list:
            folder_name = folder_dict['uri'][1:]
            try:
                builds_dates.append(int(folder_name))
            except ValueError:
                pass

        latest_build = max(artifacts_dict[settings.version])

        url = f"{server}/{repo}/{latest_build}/Electronics_{settings.version.split('_')[0][1:]}_winx64.zip"
    elif "WB" in settings.version:
        url = f"{server}/api/archive/download/{repo}-cache/winx64?archiveType=zip"
    else:
        return False
    return url


def download_file(settings, url):
    with requests.get(url, auth=(settings.username, settings.password), timeout=30, stream=True) as url_request:
        if url_request.status_code == 404:
            # in HQ cached build does not exist and will return 404. Recursively start download with new url
            download_file(settings, url.replace("-cache", ""))
            return

        destination_file = os.path.join(settings.download_path, f"temp_build_{settings.version}.zip")
        logging.info(f"Start download file from {url} to {destination_file}")
        with open(destination_file, 'wb') as f:
            shutil.copyfileobj(url_request.raw, f)


def parse_args():
    """
    Function to parse arguments provided to the script. Search for -p key to get settings path
    :return: settings_path: path to the configuration file
    """
    parser = argparse.ArgumentParser()
    # Add long and short argument
    parser.add_argument("--path", "-p", help="set path to the settings file generated by UI")
    args = parser.parse_args()

    if args.path:
        settings_path = args.path
        if not os.path.isfile(settings_path):
            logging.error("Settings file does not exist")
            return False

        logging.info(f"Settings path is set to {settings_path}")
    else:
        return False

    return settings_path


if __name__ == "__main__":
    main()
